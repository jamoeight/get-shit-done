---
phase: 04-git-checkpointing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/lib/checkpoint.sh
  - bin/ralph.sh
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Ralph aborts at startup if working tree has uncommitted changes"
    - "Ralph offers to git init if not in a repository"
    - "Each successful iteration creates a git commit"
    - "Commit failure aborts Ralph immediately"
    - "Partial/failed work is never committed"
  artifacts:
    - path: "bin/lib/checkpoint.sh"
      provides: "Git checkpointing functions"
      exports: ["validate_git_state", "create_checkpoint_commit"]
    - path: "bin/ralph.sh"
      provides: "Outer loop with checkpoint integration"
      contains: "source.*checkpoint.sh"
  key_links:
    - from: "bin/ralph.sh"
      to: "bin/lib/checkpoint.sh"
      via: "source at startup"
      pattern: 'source.*checkpoint\.sh'
    - from: "bin/ralph.sh"
      to: "validate_git_state"
      via: "function call at startup"
      pattern: "validate_git_state"
    - from: "bin/ralph.sh"
      to: "create_checkpoint_commit"
      via: "function call after handle_iteration_success"
      pattern: "create_checkpoint_commit"
---

<objective>
Implement atomic git commit checkpointing in the Ralph outer loop.

Purpose: Each successful iteration creates a git commit, enabling progress recovery from git history. Failed iterations leave no commit. Commit failure is fatal (can't checkpoint = can't continue safely).

Output: Working checkpoint.sh library and ralph.sh integration that creates commits after successful iterations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase context and research
@.planning/phases/04-git-checkpointing/04-CONTEXT.md
@.planning/phases/04-git-checkpointing/04-RESEARCH.md

# Existing code to integrate with
@bin/ralph.sh
@bin/lib/failfast.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create checkpoint.sh library</name>
  <files>bin/lib/checkpoint.sh</files>
  <action>
Create bin/lib/checkpoint.sh with two core functions:

**validate_git_state()** - Pre-flight validation at startup:
1. Check if in git repo using `git rev-parse --is-inside-work-tree`
2. If NOT in repo:
   - If interactive (`[[ -t 0 ]]`), prompt "Initialize git repository? [y/N]:"
   - If yes, run `git init`
   - If no or non-interactive, print error and return 1
3. Check for uncommitted changes using `git status --porcelain`
   - If dirty, show error with `git status --short`, return 1
4. Check detached HEAD using `git symbolic-ref -q HEAD`
   - If detached, print warning but return 0 (commits still work)
5. Return 0 on success

**create_checkpoint_commit(task_id, summary)** - Commit after success:
1. Stage STATE.md: `git add .planning/STATE.md`
2. Check if anything staged: `git diff --cached --quiet`
   - If nothing staged, print yellow warning "No changes to commit after task $task_id", return 0
3. Build commit message:
   ```
   Ralph checkpoint: ${task_id} complete

   ${summary}
   ```
4. Create commit: `git commit -m "$commit_msg"`
   - On failure, print RED error and return 1 (FATAL per CONTEXT.md)
5. Print short SHA confirmation: "Checkpoint: $short_sha ($task_id)"
6. Return 0

Use existing color codes pattern from display.sh (RED, GREEN, YELLOW, RESET).
Include proper shebang and header comments matching project conventions.
  </action>
  <verify>
Run: `bash -n bin/lib/checkpoint.sh` (syntax check)
Functions validate_git_state and create_checkpoint_commit are defined
  </verify>
  <done>
checkpoint.sh exists with validate_git_state and create_checkpoint_commit functions
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate checkpoint validation at ralph.sh startup</name>
  <files>bin/ralph.sh</files>
  <action>
Modify bin/ralph.sh to add git validation at startup:

1. Source checkpoint.sh after other lib files:
   `source "${SCRIPT_DIR}/lib/checkpoint.sh"`

2. After `show_startup_summary` call (around line 204) and BEFORE `mark_checkpoint`:
   ```bash
   # Validate git state before entering main loop
   if ! validate_git_state; then
       echo -e "${RED}Cannot proceed without clean git state${RESET}"
       exit 1
   fi
   ```

This ensures ralph aborts if:
- Not in git repo (and user declines init)
- Working tree has uncommitted changes

Do NOT modify the existing `mark_checkpoint` call - that stays for rollback purposes.
  </action>
  <verify>
Run ralph.sh in a directory with uncommitted changes - should abort
Run ralph.sh outside a git repo - should offer to init or abort
  </verify>
  <done>
ralph.sh sources checkpoint.sh and calls validate_git_state at startup
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate commit creation after successful iterations</name>
  <files>bin/ralph.sh</files>
  <action>
Modify bin/ralph.sh to create checkpoint commits after successful iterations:

1. In the success path (after `handle_iteration_success` call, around line 273), add:
   ```bash
   # Create checkpoint commit
   if ! create_checkpoint_commit "$next_task" "$summary"; then
       echo -e "${RED}FATAL: Cannot continue without successful checkpoint${RESET}"
       exit 1
   fi
   ```

2. This should come AFTER `handle_iteration_success` (which updates STATE.md) but BEFORE the existing `mark_checkpoint` call.

The order should be:
1. handle_iteration_success (updates STATE.md)
2. create_checkpoint_commit (commits STATE.md + Claude's changes)
3. mark_checkpoint (records new HEAD for rollback)

Commit failure is FATAL per CONTEXT.md - if we can't checkpoint, we can't continue safely.
  </action>
  <verify>
Run ralph.sh on a test task - after success, `git log -1` should show "Ralph checkpoint:" commit
The commit should include STATE.md changes
  </verify>
  <done>
Successful iterations create atomic git commits; commit failure exits ralph
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `bash -n bin/lib/checkpoint.sh` - no syntax errors
2. `grep -q "source.*checkpoint.sh" bin/ralph.sh` - checkpoint.sh is sourced
3. `grep -q "validate_git_state" bin/ralph.sh` - validation called at startup
4. `grep -q "create_checkpoint_commit" bin/ralph.sh` - commit created after success
5. Manual test: Stage a file, run ralph.sh - should abort with dirty tree error
</verification>

<success_criteria>
- checkpoint.sh library exists with validate_git_state and create_checkpoint_commit
- ralph.sh sources checkpoint.sh and integrates both functions
- Startup validation prevents running with dirty working tree
- Successful iterations create "Ralph checkpoint:" commits
- Commit failure causes ralph to exit immediately
- Partial/failed iterations create no commits
</success_criteria>

<output>
After completion, create `.planning/phases/04-git-checkpointing/04-01-SUMMARY.md`
</output>
