# Phase 7: Learnings Propagation - Research

**Researched:** 2026-01-19
**Domain:** Learning extraction, AGENTS.md patterns, context management
**Confidence:** HIGH

## Summary

Phase 7 implements a learning system where patterns discovered during autonomous execution are captured in `.planning/AGENTS.md` and consumed by future iterations. The research reveals that AGENTS.md is now a well-established standard for AI coding agent configuration, with over 60,000 repositories adopting it under the Linux Foundation's stewardship.

The key insight from community patterns is that AGENTS.md functions as "persistent memory across sessions" - not just configuration, but accumulated learnings that compound over time. Successful implementations use a feedback loop where failures are automatically converted into rules that prevent recurrence.

**Primary recommendation:** Use section-based organization in AGENTS.md with filtered loading based on current task context. Keep learnings minimal (one learning = one actionable statement), use deduplication on append, and implement progressive loading to avoid context bloat.

## Standard Stack

The established tools/patterns for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| sed | GNU | Extract sections between markers | Already used throughout codebase (state.sh, recovery.sh) |
| grep | GNU | Pattern matching, filtering | Used for section detection, deduplication check |
| awk | GNU | Field extraction, YAML frontmatter | Used in state.sh for line-by-line processing |

### Supporting
| Tool | Version | Purpose | When to Use |
|------|---------|---------|-------------|
| sort + uniq | GNU | Deduplication pipeline | When checking for existing learnings before append |
| mktemp | POSIX | Atomic file updates | Standard pattern from state.sh for safe writes |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| sed markers | jq + JSON | JSON harder to edit manually, sed markers already proven in codebase |
| Manual dedup | Hash-based | Hashing adds complexity, simple grep sufficient for small learning sets |
| yq for YAML | grep/sed | yq is external dependency, frontmatter is simple enough for sed |

**No installation needed:** All tools are standard POSIX/GNU utilities already available in the project's bash environment.

## Architecture Patterns

### Recommended AGENTS.md Structure
```markdown
# Project Learnings

Project-specific patterns discovered during autonomous execution.
Auto-generated by ralph.sh - manual edits preserved.

## Error Fixes

When you encounter specific errors, apply these fixes:

- When "permission denied" on shell scripts, run `chmod +x bin/*.sh`
- When "command not found: jq", use grep/sed fallback for JSON parsing

## Codebase Patterns

Project conventions discovered during execution:

- This project uses atomic write pattern: write to temp, then mv
- Test files use generic patterns (PASS/FAIL) not framework-specific
- Phase directories are zero-padded: 01-name, 02-name

## Phase-Specific

### Phase 3: Outer Loop
- Claude CLI uses -p flag for non-interactive mode
- JSON output parsed with jq when available, grep fallback otherwise

### Phase 5: Exit Conditions
- TESTS_UNKNOWN treated as passing (false negatives over false positives)
```

### Pattern 1: Section-Based Loading
**What:** Load only relevant sections from AGENTS.md based on current task context
**When to use:** When invoking Claude to avoid context bloat
**Example:**
```bash
# Source: Adapted from recovery.sh get_recent_failures pattern
get_learnings_for_phase() {
    local phase_num="$1"
    local agents_file="${AGENTS_FILE:-.planning/AGENTS.md}"

    if [[ ! -f "$agents_file" ]]; then
        return 0  # No learnings yet, OK
    fi

    # Get general sections (Error Fixes, Codebase Patterns)
    local general
    general=$(sed -n '/^## Error Fixes/,/^## /{/^## Error Fixes/d;/^## /d;p}' "$agents_file")
    general+=$'\n'
    general+=$(sed -n '/^## Codebase Patterns/,/^## /{/^## Codebase Patterns/d;/^## /d;p}' "$agents_file")

    # Get phase-specific section if it exists
    local phase_specific
    phase_specific=$(sed -n "/^### Phase ${phase_num}:/,/^### /{/^### Phase ${phase_num}:/d;/^### /d;p}" "$agents_file")

    echo "$general"
    if [[ -n "$phase_specific" ]]; then
        echo ""
        echo "Phase ${phase_num} specific:"
        echo "$phase_specific"
    fi
}
```

### Pattern 2: Learning Extraction from SUMMARY.md
**What:** Extract patterns-established and key-decisions from plan summaries
**When to use:** After successful plan completion
**Example:**
```bash
# Source: Adapted from parse.sh find_plan_file pattern
extract_learnings_from_summary() {
    local summary_file="$1"

    if [[ ! -f "$summary_file" ]]; then
        return 1
    fi

    # Extract patterns-established from YAML frontmatter
    # Format: patterns-established: ["pattern1", "pattern2"]
    local patterns
    patterns=$(sed -n '/^patterns-established:/,/^[a-z]/{
        /^patterns-established:/d
        /^[a-z]/d
        s/^[[:space:]]*- //
        s/"//g
        p
    }' "$summary_file")

    # Extract key-decisions
    local decisions
    decisions=$(sed -n '/^key-decisions:/,/^[a-z]/{
        /^key-decisions:/d
        /^[a-z]/d
        s/^[[:space:]]*- //
        s/"//g
        p
    }' "$summary_file")

    echo "PATTERNS:"
    echo "$patterns"
    echo ""
    echo "DECISIONS:"
    echo "$decisions"
}
```

### Pattern 3: Deduplicated Append
**What:** Add learning only if not already present (exact or fuzzy match)
**When to use:** When writing new learnings to AGENTS.md
**Example:**
```bash
# Source: Standard unix deduplication pattern
append_learning() {
    local section="$1"    # e.g., "Error Fixes" or "Phase 5"
    local learning="$2"
    local agents_file="${AGENTS_FILE:-.planning/AGENTS.md}"

    # Check if learning already exists (exact match)
    if grep -qF "$learning" "$agents_file" 2>/dev/null; then
        return 0  # Already exists, skip
    fi

    # Ensure file exists with structure
    if [[ ! -f "$agents_file" ]]; then
        init_agents_file
    fi

    # Find section and append
    # If section doesn't exist, create it
    if ! grep -q "^## $section" "$agents_file"; then
        echo "" >> "$agents_file"
        echo "## $section" >> "$agents_file"
        echo "" >> "$agents_file"
    fi

    # Append under section using sed
    local temp
    temp=$(mktemp)
    awk -v section="## $section" -v learning="- $learning" '
        $0 == section { print; getline; print; print learning; next }
        { print }
    ' "$agents_file" > "$temp"
    mv "$temp" "$agents_file"
}
```

### Anti-Patterns to Avoid
- **Bloated single file:** Don't dump all learnings into AGENTS.md without organization; use sections
- **Verbose prose:** Learnings should be actionable one-liners, not paragraphs
- **No deduplication:** Always check before appending to prevent repetitive content
- **Loading everything:** Use filtered loading based on task context, not full file read
- **Date/source metadata:** Per user decision, minimal metadata only - just the learning itself

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Section extraction | Custom parser | sed -n '/START/,/END/' | Proven pattern already in recovery.sh, state.sh |
| Atomic file writes | Direct echo >> | atomic_write from state.sh | Race conditions, partial writes on crash |
| YAML frontmatter | Full YAML parser | Simple sed/grep extraction | Frontmatter structure is predictable, no yq dependency |
| Deduplication | Hash table | grep -qF exact match | Learnings are short, exact match sufficient |

**Key insight:** The codebase already has robust patterns for section-based markdown manipulation (state.sh update_section, recovery.sh get_recent_failures). Reuse these patterns rather than inventing new approaches.

## Common Pitfalls

### Pitfall 1: Context Bloat from Unlimited Growth
**What goes wrong:** AGENTS.md grows unbounded, consuming context window
**Why it happens:** Every iteration adds learnings without cleanup
**How to avoid:** Implement hard cap (e.g., 50 entries max) or section limits (10 per section)
**Warning signs:** AGENTS.md exceeds 100 lines, Claude responses slow down

### Pitfall 2: Learnings Too Vague to Apply
**What goes wrong:** "Be careful with edge cases" - not actionable
**Why it happens:** Extracting learnings without specificity
**How to avoid:** Format as if-then rules: "When X happens, do Y"
**Warning signs:** Learnings without concrete actions or conditions

### Pitfall 3: Loading All Learnings Always
**What goes wrong:** Every iteration loads 50+ learnings, most irrelevant
**Why it happens:** Simpler to load everything than filter
**How to avoid:** Section-based loading tied to current phase/area
**Warning signs:** Prompt includes many learnings unrelated to current task

### Pitfall 4: Extracting During Failure
**What goes wrong:** Learnings captured from failed attempts may be wrong
**Why it happens:** Extracting after every iteration regardless of outcome
**How to avoid:** Only extract learnings after SUCCESS or after RECOVERY
**Warning signs:** AGENTS.md contains advice that doesn't actually work

### Pitfall 5: Orphaned Sections
**What goes wrong:** Phase-specific sections remain after phase reorganization
**Why it happens:** Sections tied to phase numbers that may change
**How to avoid:** Consider category-based organization (testing, shell, git) vs phase numbers
**Warning signs:** "Phase 3" section contains outdated information

## Code Examples

Verified patterns from official sources and existing codebase:

### Initialize AGENTS.md
```bash
# Source: Adapted from state.sh _init_archive_file
init_agents_file() {
    local agents_file="${AGENTS_FILE:-.planning/AGENTS.md}"

    # Ensure directory exists
    local agents_dir
    agents_dir=$(dirname "$agents_file")
    if [[ ! -d "$agents_dir" ]]; then
        mkdir -p "$agents_dir"
    fi

    # Create with initial structure
    cat > "$agents_file" << 'EOF'
# Project Learnings

Project-specific patterns discovered during autonomous execution.
Auto-generated by ralph.sh - manual edits preserved.

## Error Fixes

When you encounter specific errors, apply these fixes:

## Codebase Patterns

Project conventions discovered during execution:

## Phase-Specific

EOF
}
```

### Inject Learnings into Claude Prompt
```bash
# Source: Adapted from invoke.sh invoke_claude
build_prompt_with_learnings() {
    local task_id="$1"
    local plan_file="$2"

    # Get phase number from task_id
    local phase_num="${task_id%%-*}"

    # Get relevant learnings
    local learnings
    learnings=$(get_learnings_for_phase "$phase_num")

    # Build prompt
    local prompt
    prompt="Execute plan ${task_id}.

Read the plan file at ${plan_file}
Follow the execute-plan workflow from GSD.
Commit each task atomically.
Create SUMMARY.md when complete.
Update STATE.md with position and decisions."

    # Add learnings if any
    if [[ -n "$learnings" && "$learnings" != $'\n' ]]; then
        prompt+="

## Project Learnings (apply when relevant)

${learnings}"
    fi

    echo "$prompt"
}
```

### Extract and Store Learnings After Success
```bash
# Source: New pattern based on handle_iteration_success
extract_and_store_learnings() {
    local task_id="$1"
    local summary_file="$2"

    if [[ ! -f "$summary_file" ]]; then
        return 0  # No summary, nothing to extract
    fi

    local phase_num="${task_id%%-*}"

    # Extract patterns from SUMMARY.md frontmatter
    local patterns
    patterns=$(sed -n '/^patterns-established:/,/^[a-z]/{
        /^patterns-established:/d
        /^[a-z]/d
        s/^[[:space:]]*- //
        s/"//g
        p
    }' "$summary_file")

    # Store each pattern
    while IFS= read -r pattern; do
        if [[ -n "$pattern" ]]; then
            append_learning "Phase ${phase_num}" "$pattern"
        fi
    done <<< "$patterns"
}
```

### Size Management with Pruning
```bash
# Source: Adapted from state.sh rotate_history_at_phase_boundary
prune_agents_if_needed() {
    local agents_file="${AGENTS_FILE:-.planning/AGENTS.md}"
    local max_lines=100

    if [[ ! -f "$agents_file" ]]; then
        return 0
    fi

    local line_count
    line_count=$(wc -l < "$agents_file")

    if [[ $line_count -le $max_lines ]]; then
        return 0  # Under limit, OK
    fi

    # Log warning - user may want to manually curate
    echo "Warning: AGENTS.md has $line_count lines (limit: $max_lines)" >&2
    echo "Consider reviewing and consolidating learnings" >&2

    # For now, warn only - don't auto-prune user-visible file
    # Future: could implement relevance-based pruning
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| README for all audiences | AGENTS.md for AI agents | 2024-2025 | Dedicated machine-readable context |
| All context in one file | Progressive disclosure | 2025 | Load relevant context on-demand |
| Manual prompt engineering | Accumulated learnings | 2025 | Feedback loops improve agent over time |
| Fixed instructions | Adaptive rules | 2025 | Failures become updated rules |

**Current trends (from research):**
- AGENTS.md adopted by 60,000+ repositories under Linux Foundation stewardship
- "Progressive disclosure" pattern: ~500 tokens always loaded, rest on-demand
- Hierarchical memory: root AGENTS.md + component-specific files
- Meta-learning loops: post-session reflection to extract improvements

**Relevant to this project:**
- User decision: minimal metadata (no dates/sources/confidence)
- User decision: system-managed curation (users don't manually edit)
- User decision: filtered loading based on section match

## Open Questions

Things that couldn't be fully resolved:

1. **Optimal size limit for AGENTS.md**
   - What we know: Should stay small to avoid context bloat
   - What's unclear: Exact token/line limit that balances coverage vs brevity
   - Recommendation: Start with 100-line warning, 150-line hard cap

2. **Trigger timing for learning extraction**
   - What we know: After success is safest; after recovery also valuable
   - What's unclear: Should stuck resolution count? Does the outer loop or agent extract?
   - Recommendation: Outer loop extracts after SUCCESS from SUMMARY.md frontmatter

3. **Handling similar but not identical learnings**
   - What we know: Exact deduplication is easy with grep -qF
   - What's unclear: How to merge "use atomic writes" and "always use atomic_write pattern"
   - Recommendation: Start with exact match; if duplicates accumulate, add fuzzy matching

4. **When applied learning doesn't help**
   - What we know: Per CONTEXT.md, this is Claude's discretion
   - What's unclear: Should failed application be logged? Should learning be downranked?
   - Recommendation: Log only on success ("Applied learning: X"); silent on failure

## Sources

### Primary (HIGH confidence)
- [AGENTS.md Official Specification](https://agents.md/) - File structure, placement, multi-agent compatibility
- [GitHub Blog: How to Write a Great agents.md](https://github.blog/ai-and-ml/github-copilot/how-to-write-a-great-agents-md-lessons-from-over-2500-repositories/) - Analysis of 2,500+ repositories
- Existing codebase patterns (state.sh, recovery.sh, parse.sh) - Verified section manipulation patterns

### Secondary (MEDIUM confidence)
- [Progressive Disclosure for AI Coding Tools](https://alexop.dev/posts/stop-bloating-your-claude-md-progressive-disclosure-ai-coding-tools/) - Layered context strategy
- [From Prompts to AGENTS.md: What Survives](https://tessl.io/blog/from-prompts-to-agents-md-what-survives-across-thousands-of-runs/) - Hierarchical memory patterns
- [sed Range Patterns](https://nickjanetakis.com/blog/using-sed-range-patterns-grep-and-tr-to-parse-a-changelog-file) - Section extraction techniques
- [Unix Deduplication](https://www.cyberciti.biz/faq/unix-linux-shell-removing-duplicate-lines/) - sort/uniq patterns

### Tertiary (LOW confidence)
- General web search results on bash YAML parsing - Informational, specific patterns verified with codebase

## Metadata

**Confidence breakdown:**
- AGENTS.md structure: HIGH - Official specification + 60K+ repo adoption
- Section-based loading: HIGH - Direct extension of existing codebase patterns
- Learning extraction: MEDIUM - SUMMARY.md structure is known, extraction is straightforward
- Size management: MEDIUM - Guidelines from research, specific limits are project-dependent
- Deduplication: HIGH - Standard unix patterns, grep -qF is reliable

**Research date:** 2026-01-19
**Valid until:** 90 days (AGENTS.md spec is stable, bash patterns don't change)
