---
phase: 10-execution-commands
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - commands/gsd/autopilot.md
autonomous: true

must_haves:
  truths:
    - "Autopilot detects if plans exist for all phases"
    - "Autopilot detects incomplete prior runs and offers resume"
    - "Autopilot spawns planning if needed, then execution"
    - "User sees periodic progress updates during execution"
    - "Ctrl+C shows exit summary with resume instructions"
  artifacts:
    - path: "commands/gsd/autopilot.md"
      provides: "Complete autopilot workflow"
      min_lines: 250
  key_links:
    - from: "commands/gsd/autopilot.md"
      to: "bin/ralph.sh"
      via: "Bash tool invocation"
      pattern: "bin/ralph.sh"
    - from: "commands/gsd/autopilot.md"
      to: "commands/gsd/plan-milestone-all.md"
      via: "Task tool spawning"
      pattern: "plan-milestone-all"
---

<objective>
Complete autopilot.md with plan detection, resume detection, and execution orchestration.

Purpose: Enable the full "plan once, walk away, wake up to done" workflow via single command.
Output: Fully functional autopilot.md that orchestrates planning and execution.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-execution-commands/10-CONTEXT.md
@.planning/phases/10-execution-commands/10-RESEARCH.md
@bin/ralph.sh
@bin/lib/parse.sh
@bin/lib/state.sh
@commands/gsd/plan-milestone-all.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add plan detection and planning trigger</name>
  <files>commands/gsd/autopilot.md</files>
  <action>
Replace Step 2 placeholder in autopilot.md with complete plan detection logic:

Step 2: Detect Existing Plans

Check if plans exist for all phases:
```bash
# Count phases in ROADMAP.md
TOTAL_PHASES=$(grep -cE "^### Phase [0-9]" .planning/ROADMAP.md || echo 0)

# Count phases with PLAN.md files
PHASES_WITH_PLANS=$(find .planning/phases -name "*-*-PLAN.md" -type f 2>/dev/null | sed 's|.*phases/||;s|/.*||' | sort -u | wc -l | tr -d ' ')

if [[ "$PHASES_WITH_PLANS" -lt "$TOTAL_PHASES" ]]; then
    PLANS_NEEDED=true
    echo "Plans needed: $((TOTAL_PHASES - PHASES_WITH_PLANS)) phase(s) without plans"
fi
```

If plans exist for all phases:
- Prompt: "Plans exist for all phases. Use existing or regenerate? [use/regenerate]"
- If "use": skip planning, proceed to step 3
- If "regenerate": run planning (step 2b)

If plans missing:
- Display: "Planning needed for {count} phase(s)"
- Proceed to step 2b automatically

Step 2b: Execute Planning (if needed)

Spawn plan-milestone-all via Task tool:
```
Task(
  prompt="Run /gsd:plan-milestone-all with --skip-research flag",
  subagent_type="orchestrator",
  description="Generate all phase plans"
)
```

Wait for planning completion. If planning fails, show error and exit.
  </action>
  <verify>
- grep "Detect Existing Plans" commands/gsd/autopilot.md shows step header
- grep "PHASES_WITH_PLANS" commands/gsd/autopilot.md shows detection logic
- grep "plan-milestone-all" commands/gsd/autopilot.md shows planning trigger
  </verify>
  <done>autopilot.md detects plan existence and triggers planning when needed</done>
</task>

<task type="auto">
  <name>Task 2: Add resume detection and execution trigger</name>
  <files>commands/gsd/autopilot.md</files>
  <action>
Replace Step 3-5 placeholders with complete execution logic:

Step 3: Detect Incomplete Runs

Check STATE.md for prior incomplete execution:
```bash
# Check for iteration history with incomplete status
if [[ -f ".planning/STATE.md" ]]; then
    # Extract next action - if it's a plan ID (NN-MM), run is incomplete
    NEXT_TASK=$(grep "^Description:" .planning/STATE.md | head -1 | grep -oE '[0-9]{2}-[0-9]{2}' || echo "")

    if [[ -n "$NEXT_TASK" ]]; then
        INCOMPLETE_RUN=true
        echo "Incomplete run detected. Last position: $NEXT_TASK"
    fi
fi
```

If incomplete run detected:
- Prompt: "Resume previous run from {position}? [resume/restart]"
- If "resume": proceed with existing state
- If "restart": reset STATE.md position to first plan

Step 4: Start Execution

Display confirmation:
```
==========================================
 GSD AUTOPILOT - READY TO LAUNCH
==========================================

Mode: Lazy (autonomous)
Plans: {count} across {phases} phases
Settings:
  - Max iterations: {MAX_ITERATIONS}
  - Timeout: {TIMEOUT_HOURS}h
  - Circuit breaker: {CIRCUIT_BREAKER_THRESHOLD} failures
  - Stuck threshold: {STUCK_THRESHOLD} retries

Starting autonomous execution...
Press Ctrl+C at any time for graceful stop.
==========================================
```

Execute ralph.sh via Bash tool:
```bash
./bin/ralph.sh 2>&1
```

Step 5: Handle Completion

When ralph.sh exits, parse exit status and display appropriate message:

Exit 0 (COMPLETED):
```
==========================================
 GSD AUTOPILOT - COMPLETE
==========================================

All plans executed successfully!

Next steps:
- Review work in .planning/phases/
- Run /gsd:progress for summary
- Run /gsd:complete-milestone when ready
==========================================
```

Exit 1 (STUCK):
```
==========================================
 GSD AUTOPILOT - STUCK
==========================================

Execution stuck at: {task}
Reason: Same task failed {threshold} times

Resume: /gsd:autopilot (will offer to resume)
Debug:  /gsd:debug "investigate {task} failures"
==========================================
```

Exit 2 (ABORTED):
```
==========================================
 GSD AUTOPILOT - ABORTED
==========================================

Execution aborted.
Position saved: {task}

Resume: /gsd:autopilot
==========================================
```

Exit 3 (INTERRUPTED):
```
==========================================
 GSD AUTOPILOT - INTERRUPTED
==========================================

Graceful stop completed.
All progress committed.

Position: {task}
Completed: {N} iterations

Resume: /gsd:autopilot
==========================================
```
  </action>
  <verify>
- grep "Detect Incomplete Runs" commands/gsd/autopilot.md shows step 3
- grep "ralph.sh" commands/gsd/autopilot.md shows execution trigger
- grep "AUTOPILOT - COMPLETE" commands/gsd/autopilot.md shows completion message
- grep "AUTOPILOT - INTERRUPTED" commands/gsd/autopilot.md shows interrupt message
  </verify>
  <done>autopilot.md has complete workflow from settings through execution to completion handling</done>
</task>

</tasks>

<verification>
After both tasks:
- autopilot.md is a complete command (250+ lines)
- All 5 workflow steps implemented
- Plan detection triggers planning when needed
- Resume detection offers to continue prior runs
- Execution spawns ralph.sh and handles all exit statuses
</verification>

<success_criteria>
- Plan detection checks all phases have plans
- Planning triggered via plan-milestone-all when plans missing
- Resume detection checks STATE.md for incomplete runs
- Execution via ralph.sh with all exit status handling
- Clear completion/failure/interrupt messages with next steps
</success_criteria>

<output>
After completion, create `.planning/phases/10-execution-commands/10-02-SUMMARY.md`
</output>
